// Generated by CoffeeScript 1.6.3
(function() {
  var Cube, Object3D, Space, makeMaze, printout, removePercentMaze, run_scout,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Space = (function() {
    function Space(container) {
      var _this = this;
      this.container = container;
      this.last_time = null;
      this.objects = [];
      this.scene = new THREE.Scene;
      this.renderer = new THREE.WebGLRenderer;
      this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
      this.renderer.shadowMapEnabled = true;
      this.renderer.shadowMapSoft = true;
      this.container.appendChild(this.renderer.domElement);
      this.camera = new THREE.PerspectiveCamera(45, this.container.offsetWidth / this.container.offsetHeight, 1, 4000);
      this.camera.position.set(0, 5, 0);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      window.addEventListener('resize', function() {
        return _this.onWindowResize();
      });
      document.querySelector("#fullscreen p").addEventListener('click', function(evt) {
        return _this.toggleFullScreen(evt);
      });
      this.start_stats();
    }

    Space.prototype.addToScene = function(o) {
      return this.scene.add(o);
    };

    Space.prototype.addLight = function(x, y, z, color, intensity, castShadow) {
      var d, light;
      if (castShadow == null) {
        castShadow = false;
      }
      light = new THREE.DirectionalLight(color, intensity);
      light.position.set(x, y, z);
      if (castShadow) {
        light.castShadow = true;
        light.shadowCameraNear = 0.01;
        light.shadowCameraVisible = true;
        light.shadowMapWidth = 2048;
        light.shadowMapHeight = 2048;
        d = 10;
        light.shadowCameraLeft = -d;
        light.shadowCameraRight = d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;
        light.shadowCameraFar = 100;
        light.shadowDarkness = 0.5;
      }
      return this.addToScene(light);
    };

    Space.prototype.isFullscreen = function() {
      return document.webkitIsFullScreen || document.mozFullScreen;
    };

    Space.prototype.toggleFullScreen = function(et) {
      var el;
      el = this.container;
      if (!this.isFullscreen()) {
        if (el.requestFullscreen) {
          return el.requestFullscreen();
        } else if (el.mozRequestFullScreen) {
          return el.mozRequestFullScreen();
        } else if (el.webkitRequestFullscreen) {
          return el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
      } else {
        if (document.cancelFullScreen) {
          return document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
          return document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
          return document.webkitCancelFullScreen();
        }
      }
    };

    Space.prototype.onWindowResize = function() {
      var h, w;
      if (this.isFullscreen) {
        w = window.innerWidth;
        h = window.innerHeight;
      } else {
        w = this.container.offsetWidth;
        h = this.container.offsetHeight;
      }
      this.camera.aspect = w / h;
      this.camera.updateProjectionMatrix();
      return this.renderer.setSize(w, h);
    };

    Space.prototype.start_stats = function() {
      this.stats = new Stats;
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.left = '0px';
      this.stats.domElement.style.top = '0px';
      return document.body.appendChild(this.stats.domElement);
    };

    Space.prototype.update = function(t_step, timestamp) {
      var o, sin_speed, _i, _len, _ref, _results;
      sin_speed = timestamp / 1000 / 4;
      this.camera.position.x = Math.sin(sin_speed + Math.PI / 2) * 15;
      this.camera.position.z = Math.sin(sin_speed) * 15;
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        _results.push(o.update(t_step, timestamp));
      }
      return _results;
    };

    Space.prototype.run = function(timestamp) {
      var t_step,
        _this = this;
      if (!this.last_time) {
        this.last_time = timestamp;
      }
      t_step = timestamp - this.last_time;
      if (t_step > 0) {
        this.update(t_step, timestamp);
        this.render();
        this.last_time = timestamp;
        this.stats.update();
      }
      return requestAnimationFrame(function(par) {
        return _this.run(par);
      });
    };

    Space.prototype.add = function(obj) {
      this.scene.add(obj.object3D);
      return this.objects.push(obj);
    };

    Space.prototype.render = function() {
      return this.renderer.render(this.scene, this.camera);
    };

    return Space;

  })();

  Object3D = (function() {
    function Object3D() {}

    Object3D.prototype.update = function(t_step, timestamp) {};

    Object3D.prototype.setPosition = function(pos) {
      console.log(pos);
      this.setPos = pos;
      this.object3D.position.x = pos[0];
      this.object3D.position.y = pos[1];
      this.object3D.position.z = pos[2];
      return this;
    };

    return Object3D;

  })();

  Cube = (function(_super) {
    __extends(Cube, _super);

    function Cube(space) {
      var geometry, material;
      this.space = space;
      material = new THREE.MeshLambertMaterial({
        color: 0x888888
      });
      geometry = new THREE.CubeGeometry(1, 1, 1);
      this.object3D = new THREE.Mesh(geometry, material);
      this.object3D.castShadow = true;
      this.object3D.receiveShadow = true;
    }

    Cube.prototype.update = function(t_step, timestamp) {};

    return Cube;

  })(Object3D);

  makeMaze = function(x, y) {
    var mazeArray, size, startX, startY, w, wall, _, _i, _len, _ref;
    size = x * y;
    mazeArray = (function() {
      var _i, _results;
      _results = [];
      for (_ = _i = 0; 0 <= x ? _i < x : _i > x; _ = 0 <= x ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (_ = _j = 0; 0 <= y ? _j < y : _j > y; _ = 0 <= y ? ++_j : --_j) {
            _results1.push(true);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    startX = _.random(0, x - 1);
    startY = _.random(0, y - 1);
    mazeArray[startX][startY] = 'space';
    wall = neighbourWalls(startX, startY, x, y);
    while (wall.length() > 0) {
      w = wall.pop();
      if (breakWall(w)) {
        mazeArray[w.x][w.y] = 'space';
        _ref = neighbourWalls(w.x, w.y, x, y);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          wall.push(w);
        }
      }
    }
    return mazeArray;
  };

  removePercentMaze = function(maze, spars) {
    var i, j, mx, mz, p, _i, _j, _len, _len1;
    p = spars / 100;
    for (i = _i = 0, _len = maze.length; _i < _len; i = ++_i) {
      mx = maze[i];
      for (j = _j = 0, _len1 = mx.length; _j < _len1; j = ++_j) {
        mz = mx[j];
        if (Math.random() < p) {
          if (maze[i][j]) {
            maze[i][j] = false;
          }
        }
      }
    }
    return maze;
  };

  printout = function(o) {
    return console.log(JSON.stringify(o));
  };

  run_scout = function(container) {
    var c, castShadow, gx, gz, maze, plane, s, sizeX, sizeZ, x, z, _i, _j;
    sizeX = 15;
    sizeZ = 16;
    s = new Space(container);
    s.addLight(5, 10, 5, 0xffffff, 0.3, castShadow = true);
    plane = new THREE.Mesh(new THREE.PlaneGeometry(sizeX, sizeZ), new THREE.MeshBasicMaterial({
      color: 0x404040
    }));
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = 0;
    plane.receiveShadow = true;
    s.addToScene(plane);
    maze = makeMaze(sizeX, sizeZ);
    maze = removePercentMaze(maze, 50);
    for (x = _i = 0; 0 <= sizeX ? _i < sizeX : _i > sizeX; x = 0 <= sizeX ? ++_i : --_i) {
      for (z = _j = 0; 0 <= sizeZ ? _j < sizeZ : _j > sizeZ; z = 0 <= sizeZ ? ++_j : --_j) {
        if (maze[x][z]) {
          gx = -(sizeX / 2) + 0.5 + x;
          gz = -(sizeZ / 2) + 0.5 + z;
          c = new Cube(s).setPosition([gx, 0.5, gz]);
          s.addToScene(c.object3D);
        }
      }
    }
    return s.run(window.performance.now());
  };

  window.LL = window.LL || {};

  window.LL.run_scout = run_scout;

}).call(this);
